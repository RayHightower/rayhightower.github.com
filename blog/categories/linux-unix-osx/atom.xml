<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux-Unix-OSX | RayHightower.com]]></title>
  <link href="http://RayHightower.com/blog/categories/linux-unix-osx/atom.xml" rel="self"/>
  <link href="http://RayHightower.com/"/>
  <updated>2013-03-14T16:22:39-05:00</updated>
  <id>http://RayHightower.com/</id>
  <author>
    <name><![CDATA[Raymond T. Hightower - Chicago Ruby on Rails & iOS Developer]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Automatic ctags with RubyMotion and Vim]]></title>
    <link href="http://RayHightower.com/blog/2013/02/12/automatic-ctags-with-rubymotion-and-vim/"/>
    <updated>2013-02-12T19:35:00-06:00</updated>
    <id>http://RayHightower.com/blog/2013/02/12/automatic-ctags-with-rubymotion-and-vim</id>
    <content type="html"><![CDATA[<p><a href="/blog/2012/10/29/building-ios-apps-with-ruby-motion/">RubyMotion</a> includes a <code>rake</code> task that generates <a href="http://ctags.sourceforge.net/whatis.html">Exuberant Ctags</a>. To generate tags, run the following in the root directory of a RubyMotion project.</p>

<p><code>bash
$ rake ctags
</code></p>

<h4>Make Ctags Better With Automation</h4>

<p>Ctags make writing code more efficient. But we shouldn't have to type <code>$ rake ctags</code> every time we create a new RubyMotion project. This article shows how to use a shell script to generate ctags automatically every time you create a new RubyMotion app.</p>

<!-- more -->


<h4>How Ctags Save Time</h4>

<p>Ctags can save you time. For example, when creating a new class called <code>HomeViewController</code> that inherits from <code>UIViewController</code>, typing the first view characters of the superclass will produce the drop-down shown below.
<img src="http://RayHightower.com/images/uiviewcontroller.png" align="center" width="800" height="433" title="ctags RubyMotion Vim" alt="ctags RubyMotion Vim"></p>

<p>RubyMotion's implementation of ctags includes support for built-in iOS classes like UIViewController. The code completion and drop-downs offered by ctags will reduce keystrokes and errors, freeing the developer to focus on solving harder problems.</p>

<h4>Creating the Script</h4>

<p>Here's the script. You can use any name that suits you. My script is called <code>mmotion.command</code> (with two m's at the beginning to distinguish it from the standard <code>motion</code> command) and it's in the <code>~/bin/</code> directory.</p>

<p>``` bash</p>

<h1>!/bin/bash</h1>

<h1>Create a RubyMotion app, change into the app's directory, and run ctags.</h1>

<h1>Written by Raymond T. Hightower on February 12, 2013</h1>

<p>echo "Creating a new RubyMotion app called:" $1
motion create $1
cd $1
echo "Creating ctags for the new RubyMotion app..."
rake ctags
echo "Opening the new app in Vim..."
mvim .
echo "To use the RubyMotion console, cd into the new directory:" $1
```
All of the work is done by by four lines. The remaining lines are comments or 'echos' that tell the user what's happening while the script is running.</p>

<h4>Running the Script</h4>

<p>If <code>~/bin/</code> is in the <code>$PATH</code>, you can run the script with the following line command:
<code>bash
$ mmotion.command [app name]
</code></p>

<p>Of course, we can still do better by leveraging the power of aliases in <code>~/.bash_profile</code>.</p>

<h4>Adding an Alias to ~/.bash_profile</h4>

<p>Dropping an alias into <code>~/.bash_profile</code> streamlines the process even more. You can use any alias you want as long as it doesn't confilct with another command. Here's what my alias looks like:</p>

<p><code>bash
alias mmotion="mmotion.command"
</code></p>

<h4>Taking the Script for a Spin</h4>

<p>Now we can build a new RubyMotion app called <code>NewApp</code> with these results:</p>

<p>``` bash
~/Code/Ruby/RubyMotion$ mmotion NewApp
Creating a new RubyMotion app called: NewApp</p>

<pre><code>Create NewApp
Create NewApp/.gitignore
Create NewApp/Rakefile
Create NewApp/app
Create NewApp/app/app_delegate.rb
Create NewApp/resources
Create NewApp/spec
Create NewApp/spec/main_spec.rb
</code></pre>

<p>Creating ctags for the new RubyMotion app...
Opening the new app in Vim...
To use the RubyMotion console, cd into the new directory: NewApp</p>

<p>~/Code/Ruby/RubyMotion$
```</p>

<p>After the bash script ends, it lands in the directory from which it was originally run, no matter what directories it changed to during execution. This script will open the new app in Vim when it's done.</p>

<p>From here, you can <code>$ cd NewApp</code> and type <code>rake</code> to run the app in the iOS simulator.</p>

<h4>Feedback Welcome</h4>

<p>If you notice any glitches with this approach, feel free to send me a "heads up" via the <a href="/contact/">contact</a> form on this site or in the blog comments below.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unix for Ruby Developers]]></title>
    <link href="http://RayHightower.com/blog/2012/12/24/unix-for-ruby-developers/"/>
    <updated>2012-12-24T16:50:00-06:00</updated>
    <id>http://RayHightower.com/blog/2012/12/24/unix-for-ruby-developers</id>
    <content type="html"><![CDATA[<p><a href="http://workingwithunixprocesses.com/"><img src="http://RayHightower.com/images/working-w-unix-processes.jpg" align="right" width="350" height="266"></a>
It is gratifying to know that learning something tangentially related to Ruby will, in fact, teach me more about Ruby.</p>

<p><a href="http://workingwithunixprocesses.com/"><em>Working With Unix Processes</em></a>, by Jesse Storimer, is ostensibly about Unix internals. However, in reading this book, I have become more aware of how executables run on my favorite family of operating systems, which in turn gives me more insight into Ruby.</p>

<h3>Passing Arguments</h3>

<p>For example, what happens when we pass arguments to a process, Ruby or otherwise? How do the arguments get there? Storimer offers a 1-line Ruby program called <code>argv.rb</code> that we can use to play with the ARGV array:</p>

<p>``` bash
~/Code/Ruby/apps/sandbox$ echo 'p ARGV' > argv.rb</p>

<p>~/Code/Ruby/apps/sandbox$ ruby argv.rb what results can we expect here
["what", "results", "can", "we", "expect", "here"]</p>

<p>~/Code/Ruby/apps/sandbox$</p>

<p>```</p>

<!--more-->


<p>Once we have our hands on the ARGV array, we can parse it and manipulate it at will.</p>

<h3>Grokking Forks</h3>

<p>The section on forks contains a lot of mind-bending fun. The author offers some code to explain how forks work, but some concepts are only understandable when we write our own code. I had to write my own in order to raise my comfort level with forks.</p>

<p>Here's what the code does:</p>

<ul>
<li>In the parent process, <code>fork</code> returns the <code>pid</code> of the child process.</li>
<li>In the child process, <code>fork</code> returns <code>nil</code>.</li>
<li>Therefore, the <code>if</code> block should be executed by the parent process...</li>
<li>...and the <code>else</code> block should be executed by the child process.</li>
</ul>


<p>``` ruby
puts "Parent process pid (before fork) is #{Process.pid}.\n"</p>

<p>if fork
  current_process = Process.pid
  parent_process = Process.ppid
  printf "Entered the <em>if</em> block during Process #{current_process}."
  printf "\nThe parent of this process is #{Process.ppid}, which should be bash.\n\n"
else
  current_process = Process.pid
  parent_process = Process.ppid
  printf "Entered the <em>else</em> block during Process #{current_process}."
  printf "\nThe parent of this process is #{parent_process}, which should be the original of this process.\n\n"
end</p>

<p>```</p>

<p>Running the above Ruby code produces the following results:</p>

<p>``` bash
~/Code/Ruby/apps/sandbox$ ruby forking_around.rb
Parent process pid (before fork) is 79703.
Entered the <em>if</em> block during Process 79703.
The parent of this process is 76751, which should be bash.</p>

<p>Entered the <em>else</em> block during Process 79704.
The parent of this process is 79703, which should be the original of this process.</p>

<p>```</p>

<p>Digging further: Let's look at the names that correspond to our
<code>pids</code>.</p>

<p>``` bash
~/Code/Ruby/apps/sandbox$ ps -p 79703
  PID TTY           TIME CMD</p>

<p>~/Code/Ruby/apps/sandbox$ ps -p 79704
  PID TTY           TIME CMD</p>

<p>~/Code/Ruby/apps/sandbox$ ps -p 76751
  PID TTY           TIME CMD
76751 ttys003    0:00.40 -bash</p>

<p>~/Code/Ruby/apps/sandbox$
```</p>

<p>We get zero data for the <code>pids</code> 79703 and 79704 because those processes terminated with the program <code>forking_around.rb</code>. However, 76751 shows <code>bash</code> because bash is still running.</p>

<p>The book is full of rich playground examples that go much deeper than this. Time slips away when I get rolling with this stuff!</p>

<h3>Errata Handling</h3>

<p>The book is new so you can expect a few typos. If you run into problems with sample code, a quick Google search will lead you to the corrected text. For example, early in the book I had problems with a command that returns the maximum number of processes allowed on a system. Turns out there was a typo, and <a href="http://forums.pragprog.com/forums/261/topics/11191">the correction</a> was posted by the author himself on the publisher's errata page.</p>

<h3>Conclusion</h3>

<p>I enjoyed reading <em>Working With Unix Processes</em> because it replaces a belief in "the magic of Unix" with a sound understanding of Unix fundamentals. The book is clear and brief with plenty of examples. The author assumes that readers have at least a basic understanding of Ruby. After that, you only need a command line, IRB, and the willingness to explore.</p>
]]></content>
  </entry>
  
</feed>
